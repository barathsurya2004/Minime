/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 room.glb -k s 
*/

import React, { useEffect } from 'react'
import { useGraph } from '@react-three/fiber'
import { useGLTF, PerspectiveCamera, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { init_animations, setArmatureRef, useRoomAnimations } from './RoomAnimationController'
import { LoopOnce } from 'three'
import gsap from 'gsap'
import { useGlobal } from '@/app/providers'
// import { useControls } from 'leva'
import { SetFaceRefs } from './RoomAnimationController'
export function Room(props) {
  const { setActivity } = useGlobal()
  const group = React.useRef()
  const { scene, animations } = useGLTF('/models/room.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions, names } = useAnimations(animations, group)
  const activeActionRef = React.useRef(null)
  const previousActionRef = React.useRef(null)
  const armatureRef = React.useRef(); 
  const FaceRefs = {
    cheerful: React.createRef(),
    happy: React.createRef(),
    neutral: React.createRef(),
    sad: React.createRef(),
  }

  const Toggle_faces = (currentMood)=>{
    const moods = {
      cheerful: FaceRefs.cheerful.current,
      happy: FaceRefs.happy.current,
      neutral: FaceRefs.neutral.current,
      sad: FaceRefs.sad.current,
    }
      
    Object.values(moods).forEach((ref) => {
      if (ref) ref.visible = false
    })

    switch(currentMood){
      case 'cheerful':
        if (FaceRefs.cheerful.current) FaceRefs.cheerful.current.visible = true
        break;
      case 'happy':
        if (FaceRefs.happy.current) FaceRefs.happy.current.visible = true
        break;
      case 'neutral':
        if (FaceRefs.neutral.current) FaceRefs.neutral.current.visible = true
        break;
      case 'sad':
        if (FaceRefs.sad.current) FaceRefs.sad.current.visible = true
        break;
      default:
        // If mood is unrecognized, default to neutral
        if (FaceRefs.neutral.current) FaceRefs.neutral.current.visible = true
    }
  }



  const armatureX = 1.742
  const armatureY = 1.048
  const armatureZ = 1.785


  const rotZ = 0.729

  // const {cameraX, cameraY, cameraZ} = useControls('Camera Position', {
  //   cameraX: { value: 7.375, min: 0, max: 20, step: 0.1 },
  //   cameraY: { value: 4.339, min: 0, max: 20, step: 0.1 },
  //   cameraZ: { value: 7.927, min: 0, max: 20, step: 0.1 },
  // })
    //  const { cameraX, cameraY, cameraZ } = useControls('Camera Position', {
    //     cameraX: { value: 5.9, min: 0, max: 10, step: 0.01 },
    //     cameraY: { value: 2.8, min: 0, max: 10, step: 0.01 },
    //     cameraZ: { value: 5.7, min: 0, max: 10, step: 0.01 },
    // });

    // const { cameraRotX, cameraRotY, cameraRotZ } = useControls('Camera Rotation', {
    //     cameraRotX: { value: -.45, min: -Math.PI, max: Math.PI, step: 0.01 },
    //     cameraRotY: { value: 0.74, min: -Math.PI, max: Math.PI, step: 0.01 },
    //     cameraRotZ: { value: 0.30, min: -Math.PI, max: Math.PI, step: 0.01 },
    // });
    const cameraX = 5.7
    const cameraY = 3.4
    const cameraZ = 5.7

    const cameraRotX = -.45
    const cameraRotY = 0.74
    const cameraRotZ = 0.30


  React.useEffect(() => {
    if (armatureRef.current) {
      setArmatureRef(armatureRef.current)
    }
    return () => setArmatureRef(null)
  }, [armatureRef])
  
  // Store actions in a ref for external access
  React.useEffect(() => {
    if (group.current) {
      group.current.animationActions = actions;
    }
  }, [actions]);

  React.useEffect(() => {
    if (!props.activityState) return
    if (typeof window === 'undefined' || !window.playRoomAnimation) return
    if (!armatureRef.current) return

    useRoomAnimations(props.activityState, props.mood, props.currentHour)
    Toggle_faces(props.mood)
  }, [props.activityState, props.mood, props.currentHour]);

  // Helper function to play an animation by name
  const playAnimation = (animationName) => {
    if (actions[animationName]) {
      // Stop all other animations
      Object.keys(actions).forEach((key) => {
        actions[key].stop();
      });
      // Play the selected animation
      actions[animationName].play();
      console.log(`Playing animation: ${animationName}`);
    } else {
      console.warn(`Animation not found: ${animationName}`);
    }
  };

  // Helper function to stop an animation by name
  const stopAnimation = (animationName) => {
    if (actions[animationName]) {
      actions[animationName].stop();
    }
  };

  // Play an animation once, then blend into another
  const playAnimationWithBlend = (fromName, toName, options = {}) => {
    const fromAction = actions[fromName]
    const toAction = actions[toName]
    const fadeDuration = options.fadeDuration ?? 0.3

    if (!fromAction || !toAction) {
      console.warn('Animation not found for chaining:', { fromName, toName })
      return
    }

    // Stop all current actions
    Object.keys(actions).forEach((key) => {
      actions[key].stop()
    })

    fromAction.reset()
    fromAction.setLoop(LoopOnce, 1)
    fromAction.clampWhenFinished = true
    fromAction.fadeIn(fadeDuration).play()

    const mixer = fromAction.getMixer()
    const handleFinished = (e) => {
      if (e.action === fromAction) {
        mixer.removeEventListener('finished', handleFinished)
        toAction.reset().fadeIn(fadeDuration).play()
      }
    }

    mixer.addEventListener('finished', handleFinished)
  }

const playAnimationWithCrossfade = (fromName, toName) => {
    const fromAction = actions[fromName]
    const toAction = actions[toName]
    const fadeDuration = 1

    if (!fromAction || !toAction) return

    // Ensure we aren't trying to fade to the same animation
    if (fromAction !== toAction) {
        
       toAction.reset();
       toAction.play();
       fromAction.crossFadeTo(toAction, fadeDuration, true);

        previousActionRef.current = fromAction
        activeActionRef.current = toAction
    }
}

  // Complex chain: fromName (once) -> middleAnim (loop) + GSAP -> toName
  const playAnimationWithGsapAndBlend = (fromName, middleAnim, toName, gsapConfigFn, options = {}) => {
    const fromAction = actions[fromName]
    const middleAction = actions[middleAnim]
    const toAction = actions[toName]
    const fadeDuration = options.fadeDuration ?? 0.5

    if (!fromAction || !middleAction || !toAction) {
      console.warn('Animation not found for complex chaining:', { fromName, middleAnim, toName })
      return
    }

    // Stop all current actions
    Object.keys(actions).forEach((key) => {
      actions[key].stop()
    })

    // Play fromName once
    fromAction.reset()
    fromAction.setLoop(LoopOnce, 1)
    fromAction.clampWhenFinished = true
    fromAction.fadeIn(fadeDuration).play()

    const mixer = fromAction.getMixer()
    const handleFromFinished = (e) => {
      if (e.action === fromAction) {
        mixer.removeEventListener('finished', handleFromFinished)
        middleAction.reset().fadeIn(fadeDuration).play()
        
        // Run GSAP with callback
        const config = gsapConfigFn()
        config.onComplete = () => {
          // When GSAP completes, fade out middle and fade in final
          middleAction.fadeOut(fadeDuration)
          toAction.reset().fadeIn(fadeDuration).play()
        }
        gsap.to(getArmatureRef().position, config)
      }
    }

    mixer.addEventListener('finished', handleFromFinished)
  }

  // Pass FaceRefs to RoomAnimationController
  React.useEffect(() => {
    if (FaceRefs) {
      SetFaceRefs(FaceRefs);
    }
  }, [FaceRefs]);

  // Expose functions globally for debugging
  React.useEffect(() => {
    window.playRoomAnimation = playAnimation;
    window.stopRoomAnimation = stopAnimation;
    window.playRoomAnimationWithBlend = playAnimationWithBlend;
    window.playRoomAnimationWithCrossfade = playAnimationWithCrossfade;
    window.playRoomAnimationWithGsapAndBlend = playAnimationWithGsapAndBlend;

    if (armatureRef.current) {
      setArmatureRef(armatureRef.current)
      const initialActivity = init_animations()
      setActivity(initialActivity)
      if (props.onInitActivity) {
        props.onInitActivity(initialActivity)
      }
    }

    return () => {
      delete window.playRoomAnimation;
      delete window.stopRoomAnimation;
      delete window.playRoomAnimationWithBlend;
      delete window.playRoomAnimationWithCrossfade;
      delete window.playRoomAnimationWithGsapAndBlend;
    };
  }, [actions]);
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group ref={armatureRef} name="Armature" position={[armatureX, armatureY, armatureZ]} rotation={[Math.PI / 2, 0, rotZ]} scale={0.375}>
          <primitive object={nodes.mixamorigHips} />
          <group name="cheerful" ref={FaceRefs.cheerful}>
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM005" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM005'].geometry} material={materials.cheerful_eyes} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM005'].skeleton} />
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM005_1" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM005_1'].geometry} material={materials.cheerful_mouth} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM005_1'].skeleton} />
          </group>
          <group name="Happy" ref={FaceRefs.happy}>
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM002" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM002'].geometry} material={materials.Happy_eyes} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM002'].skeleton} />
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM002_1" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM002_1'].geometry} material={materials.Happy_mouth} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM002_1'].skeleton} />
          </group>
          <group name="neutral" ref={FaceRefs.neutral}>
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM004" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM004'].geometry} material={materials.neutral_eyes} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM004'].skeleton} />
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM004_1" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM004_1'].geometry} material={materials.neutral_mouth} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM004_1'].skeleton} />
          </group>
          <group name="Sad" ref={FaceRefs.sad}>
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM003" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM003'].geometry} material={materials.sad_eyes} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM003'].skeleton} />
            <skinnedMesh name="ChatGPT_Image_Jan_21,_2026,_08_16_13_PM003_1" geometry={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM003_1'].geometry} material={materials.sad_mouth} skeleton={nodes['ChatGPT_Image_Jan_21,_2026,_08_16_13_PM003_1'].skeleton} />
          </group>
          <skinnedMesh name="tripo_node_8cdfe2ae" geometry={nodes.tripo_node_8cdfe2ae.geometry} material={materials.tripo_mat_8cdfe2ae} skeleton={nodes.tripo_node_8cdfe2ae.skeleton} />
        </group>
                       <PerspectiveCamera makeDefault position={[cameraX, cameraY, cameraZ]} rotation={[cameraRotX, cameraRotY, cameraRotZ]} />
        {/* <PerspectiveCamera name="Camera" makeDefault={true} far={1000} near={0.1} fov={39.598} position={[cameraX, cameraY, cameraZ]} rotation={[-0.096, 0.739, 0.065]} /> */}
        <mesh name="tripo_node_86fc4c77" geometry={nodes.tripo_node_86fc4c77.geometry} material={materials.tripo_mat_86fc4c77} scale={12.058} />
        <mesh name="tripo_node_a5ab1ac3" geometry={nodes.tripo_node_a5ab1ac3.geometry} material={materials.tripo_mat_a5ab1ac3} position={[-2.09, 1.729, -4.426]} rotation={[Math.PI, 0, Math.PI]} scale={1.673} />
        <mesh name="tripo_node_bf838799" geometry={nodes.tripo_node_bf838799.geometry} material={materials.tripo_mat_bf838799} position={[-4.426, 1.004, -3.817]} scale={2.85} />
        <mesh name="tripo_node_2d514174" geometry={nodes.tripo_node_2d514174.geometry} material={materials.tripo_mat_2d514174} position={[-0.765, 1.119, 0.678]} rotation={[0.252, 0, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174001" geometry={nodes.tripo_node_2d514174001.geometry} material={materials.tripo_mat_2d514174} position={[-1.645, 1.547, 1.169]} rotation={[-Math.PI, 0.133, -Math.PI]} scale={2.333} />
        <mesh name="tripo_node_2d514174002" geometry={nodes.tripo_node_2d514174002.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174003" geometry={nodes.tripo_node_2d514174003.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174004" geometry={nodes.tripo_node_2d514174004.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174005" geometry={nodes.tripo_node_2d514174005.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174006" geometry={nodes.tripo_node_2d514174006.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174007" geometry={nodes.tripo_node_2d514174007.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174008" geometry={nodes.tripo_node_2d514174008.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174009" geometry={nodes.tripo_node_2d514174009.geometry} material={materials.tripo_mat_2d514174} position={[0.463, 1.137, 0.017]} rotation={[0, 0, 0.149]} scale={2.333} />
        <mesh name="tripo_node_2d514174010" geometry={nodes.tripo_node_2d514174010.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174011" geometry={nodes.tripo_node_2d514174011.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174012" geometry={nodes.tripo_node_2d514174012.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174013" geometry={nodes.tripo_node_2d514174013.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_2d514174014" geometry={nodes.tripo_node_2d514174014.geometry} material={materials.tripo_mat_2d514174} position={[0.142, 0.993, 0]} scale={2.333} />
        <mesh name="tripo_node_512d8c9d" geometry={nodes.tripo_node_512d8c9d.geometry} material={materials.tripo_mat_512d8c9d} position={[-2.533, 2.087, -4.235]} rotation={[-Math.PI, -0.073, -1.801]} scale={0.486} />
      </group>
    </group>
  )
}

useGLTF.preload('/models/room.glb')
